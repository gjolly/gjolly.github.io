[{"ref":"/blog/unified_kernel_sb/","title":"FDE, Secureboot and unified kernel image","section":"blog","tags":["Linux","Kernel","Boot","Ubuntu"],"date":"2022.11.13","body":"Full Disk Encryption, Secureboot and Unified Kernel Image FDE protect your data at rest and Secureboot makes sure what you boot is trusted. But there is a flow.\nThe flow In order to decrypt the root filesystem, the kernel uses a initial ram disk (initramfs). The initramfs provides an temporary filesystem from which extra kernel modules can be loaded, it also contains a set of scripts used to boot the system including scripts to decrypt the user\u0026rsquo;s root filesystem. This initramfs image is a file stored un-encrypted next to the kernel image. However, unlike the kernel image, it is not signed by the kernel publisher as the iniramfs is generated locally and can be modified by the user. Thus, anyone with physical access to the user\u0026rsquo;s drive can inject a malicious initramfs that would log the user\u0026rsquo;s passphrase and thus make FDE useless.\nHow to fix it We can bundle the kernel and initramfs together in a single binary and sign this binary locally. Thus, modifying the initramfs would prevent the system from booting.\nIn practice On systems using mkinitcpio or dracut see this article: https://wiki.archlinux.org/title/Unified_kernel_image#Preparing_a_unified_kernel_image.\nOn Ubuntu To create the unified EFI binary:\nsudo add-apt-repository ppa:snappy-dev/image sudo apt-get -y install ubuntu-core-initramfs sudo ubuntu-core-initramfs create-efi --unsigned --output \u0026#34;kernel.efi.unsigned\u0026#34; \\ --cmdline \u0026#34;$(cut -f 2- -d\u0026#39; \u0026#39; /proc/cmdline)\u0026#34; \\ --kernel \u0026#34;/boot/vmlinuz\u0026#34; \\ --kernelver \u0026#34;$(uname -r)\u0026#34; \\ --initrd \u0026#34;/boot/initrd.img\u0026#34; Create and enroll a new MOK:\n# You can let everything as default, or customize the fields, it doesn\u0026#39;t matter openssl req -new -x509 -newkey rsa:2048 \\ -nodes -days 36500 -outform DER \\ -keyout \u0026#34;MOK.priv\u0026#34; \\ -out \u0026#34;MOK.der\u0026#34; openssl x509 -in MOK.der -inform DER -outform PEM -out MOK.pem sudo mokutil --import MOK.der Restart your system and follow the instructions to enroll the key.\nSign the Kernel EFI:\nsudo sbsign --key MOK.priv --cert MOK.pem kernel.efi.unsigned --output kernel.efi Move it do the ESP (or to the /boot partition), example:\nsudo mv kernel.efi /boot/efi/EFI/ubuntu Add a new boot entry to boot on this kernel, example (make sure to point change --disk and --part to your ESP):\nsudo efibootmgr --create --disk /dev/vda --part 15 --label \u0026#34;Ubuntu $(uname -r)\u0026#34; --loader \u0026#34;\\EFI\\ubuntu\\shimx64.efi\u0026#34; -u \u0026#34;\\EFI\\ubuntu\\kernel.efi\u0026#34; Next To make it persistent:\nMake the kernel hook for ubuntu-core-initramfs use your keys:\nsudo mkdir /etc/custom-mok/ sudo mv MOK.priv MOK.pem /etc/custom-mok/ and modify the hook itself at /etc/kernel/postinst.d/ubuntu-core-initramfs:\nubuntu-core-initramfs create-efi --key /etc/custom-mok/MOK.priv --cert /etc/custom-mok/MOK.pem --kernelver $version create two new hooks:\ncat /etc/kernel/postinst.d/zz-update-efi-boot #!/bin/sh set -e version=\u0026#34;$1\u0026#34; command -v efibootmgr \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || exit 0 part_dev=\u0026#34;$(blkid | grep \u0026#39;LABEL_FATBOOT=\u0026#34;UEFI\u0026#34;\u0026#39; | cut -f1 -d\u0026#39;:\u0026#39;)\u0026#34; disk=\u0026#34;/dev/$(lsblk -ndo pkname ${part_dev})\u0026#34; part_name=${part_dev##/dev/} part_num=\u0026#34;$(cat /sys/class/block/${part_name}/partition)\u0026#34; # Let\u0026#39;s not duplicate the entry if it already exist efibootmgr | grep -q \u0026#34;$version\u0026#34; \u0026amp;\u0026amp; exit 0 echo \u0026#34;adding new EFI boot entry\u0026#34; efibootmgr -q --create --disk \u0026#34;$disk\u0026#34; --part \u0026#34;$part_num\u0026#34; --label \u0026#34;Ubuntu $version\u0026#34; --loader \u0026#34;\\EFI\\ubuntu\\shimx64.efi\u0026#34; -u \u0026#34;\\EFI\\ubuntu\\kernel.efi-$version\u0026#34; cat /etc/kernel/postrm.d/zz-update-efi-boot #!/bin/sh set -e version=\u0026#34;$1\u0026#34; command -v efibootmgr \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || exit 0 BOOT_NUM=$(efibootmgr | grep \u0026#34;$version\u0026#34; | cut -f1 -d\u0026#39;*\u0026#39; | sed \u0026#39;s/Boot\\(.*\\)/\\1/\u0026#39;) if [ -f \u0026#34;$BOOT_NUM\u0026#34; ]; then exit 0 fi efibootmgr -q -b \u0026#34;$BOOT_NUM\u0026#34; -B and make sure it they are executable.\n"},{"ref":"/blog/ufw/","title":"Firewall, Tailscale and Ubuntu","section":"blog","tags":["Linux","Security","Ubuntu"],"date":"2021.11.14","body":"Firewall, Tailscale and Ubuntu I recently enabled the Firewall on my desktop on Ubuntu. I probably did a quick lookup online to find out that sudo ufw enable was enough to enable it. I entered the command and forgot about it.\n$ sudo ufw enable Firewall is active and enabled on system startup Obviously, (and to be honest I was waiting for it), it didn\u0026rsquo;t take long for things to go bad. A few weeks later, while I was not at home and wanted to SSH on my machine via tailscale, I realized that I couldn\u0026rsquo;t and quickly remember about the Firewall.\nQuick side note here: I configured sshd to only bind to the tailscale IP address. I don\u0026rsquo;t want to expose my desktop on the internet.\nUncomplicated FireWall ufw was introduced by Ubuntu to ease firewall configuration.\nOn Linux, \u0026ldquo;Firewalling\u0026rdquo; is usually done through the Netfilter subsystem which can be configured via the userspace tool nftables (successor of iptables). Because nftables is made to be very generic and provides a full interface for the Netfilter subsystem, while being very powerfull it is not easy to learn.\nufw is a simplified interface on top nftables. It helps the user to define simple Firewall rules.\nThis blog post describes basic use cases.\nAllow SSH on tailscale only A very cool feature of ufw is the notion of app. An app is defined by a config file stored in /etc/ufw/applications.d. Apps can be listed with ufw app list.\nOn my system I already had the OpenSSH app configured:\n$ cat /etc/ufw/applications.d/openssh-server [OpenSSH] title=Secure shell server, an rshd replacement description=OpenSSH is a free implementation of the Secure Shell protocol. ports=22/tcp Indeed, on Ubuntu, this configuration file is shipped with the openssh-server package. Now to enable OpenSSH on tailscale for both IPv4 and IPv6, I can simply run:\nsudo ufw allow in on tailscale0 from any to any app OpenSSH "}]