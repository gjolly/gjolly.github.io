[{"ref":"/blog/unified_kernel_sb/","title":"FDE, Secureboot and unified kernel image","section":"blog","tags":["Linux","Kernel","Boot","Ubuntu"],"date":"2022.11.13","body":"Full Disk Encryption, Secureboot and Unified Kernel Image FDE protect your data at rest and Secureboot makes sure what you boot is trusted. But there is a flow.\nThe flow In order to decrypt the root filesystem, the kernel uses a initial ram disk (initramfs). The initramfs provides an temporary filesystem from which extra kernel modules can be loaded, it also contains a set of scripts used to boot the system including scripts to decrypt the user\u0026rsquo;s root filesystem. This initramfs image is a file stored un-encrypted next to the kernel image. However, unlike the kernel image, it is not signed by the kernel publisher as the iniramfs is generated locally and can be modified by the user. Thus, anyone with physical access to the user\u0026rsquo;s drive can inject a malicious initramfs that would log the user\u0026rsquo;s passphrase and thus make FDE useless.\nHow to fix it We can bundle the kernel and initramfs together in a single binary and sign this binary locally. Thus, modifying the initramfs would prevent the system from booting.\nIn practice On systems using mkinitcpio or dracut see this article: https://wiki.archlinux.org/title/Unified_kernel_image#Preparing_a_unified_kernel_image.\nOn Ubuntu To create the unified EFI binary:\nsudo add-apt-repository ppa:snappy-dev/image sudo apt-get -y install ubuntu-core-initramfs sudo ubuntu-core-initramfs create-efi --unsigned --output \u0026#34;kernel.efi.unsigned\u0026#34; \\ --cmdline \u0026#34;$(cut -f 2- -d\u0026#39; \u0026#39; /proc/cmdline)\u0026#34; \\ --kernel \u0026#34;/boot/vmlinuz\u0026#34; \\ --kernelver \u0026#34;$(uname -r)\u0026#34; \\ --initrd \u0026#34;/boot/initrd.img\u0026#34; Create and enroll a new MOK:\n# You can let everything as default, or customize the fields, it doesn\u0026#39;t matter openssl req -new -x509 -newkey rsa:2048 \\ -nodes -days 36500 -outform DER \\ -keyout \u0026#34;MOK.priv\u0026#34; \\ -out \u0026#34;MOK.der\u0026#34; openssl x509 -in MOK.der -inform DER -outform PEM -out MOK.pem sudo mokutil --import MOK.der Restart your system and follow the instructions to enroll the key.\nSign the Kernel EFI:\nsudo sbsign --key MOK.priv --cert MOK.pem kernel.efi.unsigned --output kernel.efi Move it do the ESP (or to the /boot partition), example:\nsudo mv kernel.efi /boot/efi/EFI/ubuntu Add a new boot entry to boot on this kernel, example (make sure to point change --disk and --part to your ESP):\nsudo efibootmgr --create --disk /dev/vda --part 15 --label \u0026#34;Ubuntu $(uname -r)\u0026#34; --loader \u0026#34;\\EFI\\ubuntu\\shimx64.efi\u0026#34; -u \u0026#34;\\EFI\\ubuntu\\kernel.efi\u0026#34; Next To make it persistent:\nMake the kernel hook for ubuntu-core-initramfs use your keys:\nsudo mkdir /etc/custom-mok/ sudo mv MOK.priv MOK.pem /etc/custom-mok/ and modify the hook itself at /etc/kernel/postinst.d/ubuntu-core-initramfs:\nubuntu-core-initramfs create-efi --key /etc/custom-mok/MOK.priv --cert /etc/custom-mok/MOK.pem --kernelver $version create two new hooks:\ncat /etc/kernel/postinst.d/zz-update-efi-boot #!/bin/sh set -e version=\u0026#34;$1\u0026#34; command -v efibootmgr \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || exit 0 part_dev=\u0026#34;$(blkid | grep \u0026#39;LABEL_FATBOOT=\u0026#34;UEFI\u0026#34;\u0026#39; | cut -f1 -d\u0026#39;:\u0026#39;)\u0026#34; disk=\u0026#34;/dev/$(lsblk -ndo pkname ${part_dev})\u0026#34; part_name=${part_dev##/dev/} part_num=\u0026#34;$(cat /sys/class/block/${part_name}/partition)\u0026#34; # Let\u0026#39;s not duplicate the entry if it already exist efibootmgr | grep -q \u0026#34;$version\u0026#34; \u0026amp;\u0026amp; exit 0 echo \u0026#34;adding new EFI boot entry\u0026#34; efibootmgr -q --create --disk \u0026#34;$disk\u0026#34; --part \u0026#34;$part_num\u0026#34; --label \u0026#34;Ubuntu $version\u0026#34; --loader \u0026#34;\\EFI\\ubuntu\\shimx64.efi\u0026#34; -u \u0026#34;\\EFI\\ubuntu\\kernel.efi-$version\u0026#34; cat /etc/kernel/postrm.d/zz-update-efi-boot #!/bin/sh set -e version=\u0026#34;$1\u0026#34; command -v efibootmgr \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || exit 0 BOOT_NUM=$(efibootmgr | grep \u0026#34;$version\u0026#34; | cut -f1 -d\u0026#39;*\u0026#39; | sed \u0026#39;s/Boot\\(.*\\)/\\1/\u0026#39;) if [ -f \u0026#34;$BOOT_NUM\u0026#34; ]; then exit 0 fi efibootmgr -q -b \u0026#34;$BOOT_NUM\u0026#34; -B and make sure it they are executable.\n"},{"ref":"/blog/grub_less/","title":"Boot Linux without GRUB","section":"blog","tags":["Linux","Kernel","Boot"],"date":"2021.11.19","body":"Boot Linux without GRUB To boot the Linux Kernel, most distro use a bootloader and one of the most popular is GRUB. But did you know you can directly boot the Kernel without using a bootloader?\nDISCLAIMER: This is only for fun and learning, I do not advise anyone to do that on their main system. Be safe, use a VM.\nVM setup Just a quick recap of what is needed (mostely stolen from powersj\u0026rsquo;s excelent blog post).\nSetup the user-data (for cloud-init) to be able to SSH into the VM:\ncat \u0026gt; user-data.yaml \u0026lt;\u0026lt;EOF #cloud-config ssh_authorized_keys: - ssh-rsa AAAAB3NzaC1yc2EAAAABIwJJJQEA3I7VUf3l5gSn5uavROsc5HRDpZ ... ssh_import_id: - gh:\u0026lt;github user\u0026gt; - lp:\u0026lt;launchpad user\u0026gt; EOF # cloud-localds is shipped in [cloud image utils](cloud-image-utils) cloud-localds seed.img user-data.yaml Copy the EFI vars to a temp place (they will get modified)\ncp /usr/share/OVMF/OVMF_VARS.fd /tmp/ Download an Ubuntu cloud-image and launch the VM with the cloud-init metadata and the EFI firemware.\ncurl -O http://cloud-images.ubuntu.com/releases/21.10/release/ubuntu-21.10-server-cloudimg-amd64.img qemu-system-x86_64 \\ -nographic \\ -cpu host \\ -enable-kvm \\ -smp 4 \\ -m 4G \\ -drive if=virtio,format=qcow2,file=ubuntu-21.10-server-cloudimg-amd64.img \\ -drive if=virtio,format=raw,file=./seed.img \\ -device virtio-net-pci,netdev=net0 --netdev user,id=net0,hostfwd=tcp::2222-:22 \\ -drive if=pflash,format=raw,readonly=on,file=/usr/share/OVMF/OVMF_CODE.fd \\ -drive if=pflash,format=raw,file=/tmp/OVMF_VARS.fd To SSH into the VM: ssh ubuntu@0.0.0.0 -p 2222\nIn practice First, check if your Kernel config allows this:\n$ cat /boot/config-$(uname -r) [|](|) grep EFI_STUB CONFIG_EFI_STUB=y Then, copy the Kernel and initrd to the EFI partition:\ncp -v /boot/initrd.img-* /boot/efi/EFI/ cp -v /boot/vmlinuz-$(uname -r) /boot/efi/EFI/vmlinuz-$(uname -r).efi In theory, you can put those files wherever you want on the EFI partition (Ubuntu uses /EFI/ubuntu for example). Just be carefull about the length of the EFI stub path, see this thread.\nNow we need to find out some information about the system:\nOn which device (and partition) is located the root filesystem? On which device and which partition is the EFI partition? Example:\n$ lsblk -o NAME,MOUNTPOINT,LABEL NAME MOUNTPOINT LABEL fd0 loop0 /snap/core20/1169 loop1 /snap/lxd/21780 loop2 /snap/snapd/13640 sr0 vda ├─vda1 / cloudimg-rootfs ├─vda14 └─vda15 /boot/efi UEFI vdb cidata On this system, the root filesystem is in /dev/vda1 and the EFI partition is on the same device /dev/vda on partition number 15.\nNow, let\u0026rsquo;s add a new boot entry in the UEFI boot manager\nefibootmgr --create --disk /dev/vda --part 15 --label grub-less --loader \u0026#34;\\EFI\\vmlinuz-$(uname -r).efi\u0026#34; -u \u0026#34;root=/dev/vda1 initrd=\\\\EFI\\\\initrd.img-$(uname -r) ro console=ttyS0\u0026#34; efibootmgr is a CLI tool to manipulate the UEFI boot manager (no one could have guessed it :D) --create indicates we want to create a new boot entry --disk specifies the disk containing the bootloader (here the Kernel) --part is the partition where the boot loader (here the Kernel) is --label is simply the name we want to give to this new boot entry --loader is the actual bootloader we want to call, here it is the Kernel we previously copied -u is used to pass arguments to the boot loader. Here we pass the location of initrd and the other usual Kernel command line arguments (check /proc/cmdline to find out which cmdline arguments are currently in use) The current boot entries can then be checked with: efibootmgr (no arg). The new boot entry we just created should already be the first one in the bootorder list.\nReboot!! The system should start directly without going through the GRUB.\nAt the very beginning of the serial console, we can find:\nBdsDxe: loading Boot0008 \u0026#34;grub-less\u0026#34; from HD(15,GPT,CB5D0560-825B-4575-A9E3-F3263C410054,0x2800,0x35000)/\\EFI\\vmlinuz-5.13.0-20-generic.efi BdsDxe: starting Boot0008 \u0026#34;grub-less\u0026#34; from HD(15,GPT,CB5D0560-825B-4575-A9E3-F3263C410054,0x2800,0x35000)/\\EFI\\vmlinuz-5.13.0-20-generic.efi EFI stub: Loaded initrd from command line option Troubleshooting If something goes really wrong and the system doesn\u0026rsquo;t boot, use this post to mount the EFI partition locally and simply delete the Kernel\u0026rsquo;s EFI from it. The new entry will just fail to find the EFI stub and fallback to the old boot entry.\nTo delete a boot entry: efibootmgr -b NUM -B\nRefs https://askubuntu.com/a/511019 The main source for this blog post https://www.kubuntuforums.net/showthread.php?60193-Going-GRUB-less-with-UEFI\u0026amp;p=309923\u0026amp;viewfull=1#post309923 An undocumented issue https://powersj.io/posts/ubuntu-qemu-cli/ to know more about how to use QEMU https://docs.kernel.org/admin-guide/efi-stub.html The official Kernel doc about this Kernel feature https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html more about Kernel command line "},{"ref":"/blog/qemu_cheatsheet/","title":"QEMU cheatsheet","section":"blog","tags":["Linux","QEMU"],"date":"2021.11.19","body":"QEMU cheatsheet The basics https://powersj.io/posts/ubuntu-qemu-cli/\nMount disk images It is ofter very convenient to mount a FS locally to be able to debug and/or fix a problem with a broken disk.\nPre-requisite to everything: mkdir /tmp/rootfs\nTo know the format of your disk: qemu-img info disk.img (note that qemu-img can output JSON to automate your stuff)\nRaw disk images losetup -f -P disk.img losetup -l | grep -v snap # to find the loop device you just created and yeah those snaps.... mount /dev/loopXpX /tmp/rootfs For anything else (QCOW2, VHD/VPC, etc\u0026hellip;) modprobe nbd qemu-nbd --connect=/dev/nbd0 disk.img fdisk /dev/nbd0 -l # to find your partition mount /dev/nbd0pX /tmp/rootfs "},{"ref":"/blog/ufw/","title":"Firewall, Tailscale and Ubuntu","section":"blog","tags":["Linux","Security","Ubuntu"],"date":"2021.11.14","body":"Firewall, Tailscale and Ubuntu I recently enabled the Firewall on my desktop on Ubuntu. I probably did a quick lookup online to find out that sudo ufw enable was enough to enable it. I entered the command and forgot about it.\n$ sudo ufw enable Firewall is active and enabled on system startup Obviously, (and to be honest I was waiting for it), it didn\u0026rsquo;t take long for things to go bad. A few weeks later, while I was not at home and wanted to SSH on my machine via tailscale, I realized that I couldn\u0026rsquo;t and quickly remember about the Firewall.\nQuick side note here: I configured sshd to only bind to the tailscale IP address. I don\u0026rsquo;t want to expose my desktop on the internet.\nUncomplicated FireWall ufw was introduced by Ubuntu to ease firewall configuration.\nOn Linux, \u0026ldquo;Firewalling\u0026rdquo; is usually done through the Netfilter subsystem which can be configured via the userspace tool nftables (successor of iptables). Because nftables is made to be very generic and provides a full interface for the Netfilter subsystem, while being very powerfull it is not easy to learn.\nufw is a simplified interface on top nftables. It helps the user to define simple Firewall rules.\nThis blog post describes basic use cases.\nAllow SSH on tailscale only A very cool feature of ufw is the notion of app. An app is defined by a config file stored in /etc/ufw/applications.d. Apps can be listed with ufw app list.\nOn my system I already had the OpenSSH app configured:\n$ cat /etc/ufw/applications.d/openssh-server [OpenSSH] title=Secure shell server, an rshd replacement description=OpenSSH is a free implementation of the Secure Shell protocol. ports=22/tcp Indeed, on Ubuntu, this configuration file is shipped with the openssh-server package. Now to enable OpenSSH on tailscale for both IPv4 and IPv6, I can simply run:\nsudo ufw allow in on tailscale0 from any to any app OpenSSH "},{"ref":"/blog/who/","title":"The UNIX `who` command","section":"blog","tags":["Linux","utmp","UNIX"],"date":"2020.08.31","body":"The who command While working on a completely different project, I started to ask myself how the who command was working under the hood. In the end, I thought it was a good topic for a blog post.\nWho is who Let\u0026rsquo;s start with the basics. the who command allows you to list the users currently logged on the system. For example, on my machine:\n$ who gauthier tty2 2020-08-30 15:06 (tty2) gauthier pts/1 2020-08-30 15:06 (tmux(1555).%0) gauthier pts/2 2020-08-30 16:41 (tmux(1555).%6) gauthier pts/4 2020-08-30 15:57 (tmux(1555).%3) It tells me that I am logged on the \u0026ldquo;physical\u0026rdquo; terminal tty2 and on three pseudo terminals. Indeed my current session of Gnome Shell is running on tty2 and I have 3 tmux windows open.\nBut where is it getting those information? Probably from a file as everything is a file with Linux, but let\u0026rsquo;s check which one and how the data is stored there.\nA bit of reverse engineering In order to see what the who command is doing I could try to find the source code and dig into it. But I found it fun to use strace to check what the process was doing instead. Since we are expecting who to read system files, we can only focus on the open syscalls.\n$ strace who 2\u0026gt;\u0026amp;1 | grep open openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/usr/lib/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/usr/lib/locale/locale-archive\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/var/run/utmp\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/etc/localtime\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 We can quickly filter what is interesting and what is not. The first files two files /etc/ld.so.cache, /usr/lib/libc.so.6 are shared libraries loaded by the process, those are interesting us.\nThen /usr/lib/locale/locale-archive, /var/run/utmp and /etc/localtime are opened. Let\u0026rsquo;s see what those files are storing.\nWhen exploring this kind of topics, it is always interesting to first search into the man pages before starting browsing the web. The 5th section of the manual is dedicated to \u0026ldquo;file formats and conventions\u0026rdquo; and seems a good place to start.\nlocale-archive $ man -wK 5 \u0026#39;/usr/lib/locale/locale-archive\u0026#39; Sends us to locale(5) where we can read:\nThe locale definition file contains all the information that the localedef(1) command needs to convert it into the binary locale data‐base. The page also sends us to locale(7) for more explanation about those informations:\nA locale is a set of language and cultural rules. These cover aspects such as language for messages, different character sets, lexico‐graphic conventions, and so on. A program needs to be able to determine its locale and act accordingly to be portable to different cultures. So the who command read from this file, probably using the setlocale(3) function, to find out how the information should be formated and displayed.\nWe can actually check it:\n$ LC_ALL=\u0026#39;fr_FR.utf8\u0026#39; who gauthier tty2 Sep 2 11:38 (:1) gauthier pts/1 Sep 2 12:11 (tmux(2445).%0) gauthier pts/2 Sep 2 12:37 (tmux(2445).%1) gauthier pts/3 Sep 2 13:04 (tmux(2445).%2) Indeed, the date is is not formated the same way!\nlocaltime $ man -wK 5 \u0026#39;/etc/localtime\u0026#39; Sends us to localtime(5) which explains:\nThe /etc/localtime file configures the system-wide timezone of the local system that is used by applications for presentation to the user. Probably who uses this file (or uses a function that is using this file) to print timestamps (columns 4 and 5 of who\u0026rsquo;s output) using the correct timezone configured by the user.\nutmp Finally comes /var/run/utmp:\n$ man -wK 5 \u0026#39;/var/run/utmp\u0026#39; /usr/share/man/man5/utmp.5.gz Where we can read:\nThe utmp file allows one to discover information about who is currently using the system. There may be more users currently using the system, because not all programs use utmp logging. Great! We found where the who command is getting its data. It would be nice to be able to read this file to get those data without using the who command. Unfortunately:\nThe file is a sequence of utmp structures, declared as follows in \u0026lt;utmp.h\u0026gt; (note that this is only one of several definitions around; details depend on the version of libc): At this point we understood what the who command is doing: it is reading /var/run/utmp, parsing the content and formating it nicely. Let\u0026rsquo;s see if we can reproduce this simple behavior.\nMy own who What we simply need to do is: open /var/run/utmp, read n bytes (where n is the size of the utmp structure), print the info contained in each structure, continue until we reach the end of the file. With a bit of formating, we can even make it look like the original who command.\n#include \u0026lt;utmp.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;locale.h\u0026gt; int main() { // set the right locale to display the information nicely setlocale(LC_ALL, \u0026#34;\u0026#34;); // open the file FILE * file= fopen(\u0026#34;/var/run/utmp\u0026#34;, \u0026#34;rb\u0026#34;); // just for safety if (file == NULL) { return 1; } // initialize the utmp structure struct utmp entry; // read the entries from the file one by one while (fread(\u0026amp;entry, sizeof(struct utmp), 1, file) != 0) { if (entry.ut_type != USER_PROCESS) continue; // format the date (remember who uses the /etc/localtime?) char date[80]; time_t raw_time = entry.ut_tv.tv_sec; struct tm *ts = localtime(\u0026amp;raw_time); strftime(date, sizeof(date), \u0026#34;%Y-%m-%d %H:%M\u0026#34;, ts); // print the output for this entry, tries to mock who\u0026#39;s output printf(\u0026#34;%-8s %-12s %s (%s)\\n\u0026#34;, entry.ut_user, entry.ut_line, date, entry.ut_host); } fclose(file); } $ clang -o who who.c $ ./who gauthier tty2 2020-08-31 10:02 (tty2) gauthier pts/1 2020-08-31 10:03 (tmux(2220).%0) gauthier pts/2 2020-08-31 10:08 (tmux(2220).%1) gauthier pts/3 2020-08-31 10:33 (tmux(2220).%5) TADA!\nWe can also check with strace if the behavior is the same:\n$ strace ./who 2\u0026gt;\u0026amp;1 | grep -e open openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/usr/lib/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/usr/lib/locale/locale-archive\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/var/run/utmp\u0026#34;, O_RDONLY) = 3 openat(AT_FDCWD, \u0026#34;/etc/localtime\u0026#34;, O_RDONLY|O_CLOEXEC) = 4 Indeed our program is doing the same as the original who.\nOf course, this only mocks the most basic features of the who command and doesn\u0026rsquo;t handle any option, like the famous who am i or who mom hates.\nGoing further There is still a lot to say about the who command. We could for example mention the lastlog command and its corresponding file /var/log/wtmp, dig into the utmp structure, or just try to understand what utmp stands for.\n"}]