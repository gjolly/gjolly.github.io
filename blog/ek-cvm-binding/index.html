<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The trust model of vTPM in Confidential VMs | Gauthier Jolly</title><meta name=keywords content="Confidential Computing,TPM"><meta name=description content="In a previous post, I explained that the direction most Confidential Computing deployments are converging toward is to reintroduce the TPM abstraction inside the Confidential VM itself. Rather than relying on a physical TPM, the goal is to expose a TPM interface from within the TEE.
This design choice is largely pragmatic. It enables a lift-and-shift model for existing operating systems and workloads that already depend on TPMs for measured boot, disk encryption, and remote attestation. At the same time, it preserves the familiar TPM security guarantees while replacing physical trust assumptions with hardware-enforced isolation."><meta name=author content="Gauthier Jolly"><link rel=canonical href=https://gjolly.fr/blog/ek-cvm-binding/><link crossorigin=anonymous href=https://gjolly.fr/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://gjolly.fr/img/terminal-sign.svg><link rel=icon type=image/png sizes=16x16 href=https://gjolly.fr/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gjolly.fr/favicon-32x32.png><link rel=apple-touch-icon href=https://gjolly.fr/apple-touch-icon.png><link rel=mask-icon href=https://gjolly.fr/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://gjolly.fr/blog/ek-cvm-binding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4G50Q2695"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4G50Q2695")}</script><meta property="og:url" content="https://gjolly.fr/blog/ek-cvm-binding/"><meta property="og:site_name" content="Gauthier Jolly"><meta property="og:title" content="The trust model of vTPM in Confidential VMs"><meta property="og:description" content="In a previous post, I explained that the direction most Confidential Computing deployments are converging toward is to reintroduce the TPM abstraction inside the Confidential VM itself. Rather than relying on a physical TPM, the goal is to expose a TPM interface from within the TEE.
This design choice is largely pragmatic. It enables a lift-and-shift model for existing operating systems and workloads that already depend on TPMs for measured boot, disk encryption, and remote attestation. At the same time, it preserves the familiar TPM security guarantees while replacing physical trust assumptions with hardware-enforced isolation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-21T17:30:00+00:00"><meta property="article:modified_time" content="2026-01-21T17:30:00+00:00"><meta property="article:tag" content="Confidential Computing"><meta property="article:tag" content="TPM"><meta name=twitter:card content="summary"><meta name=twitter:title content="The trust model of vTPM in Confidential VMs"><meta name=twitter:description content="In a previous post, I explained that the direction most Confidential Computing deployments are converging toward is to reintroduce the TPM abstraction inside the Confidential VM itself. Rather than relying on a physical TPM, the goal is to expose a TPM interface from within the TEE.
This design choice is largely pragmatic. It enables a lift-and-shift model for existing operating systems and workloads that already depend on TPMs for measured boot, disk encryption, and remote attestation. At the same time, it preserves the familiar TPM security guarantees while replacing physical trust assumptions with hardware-enforced isolation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://gjolly.fr/blog/"},{"@type":"ListItem","position":2,"name":"The trust model of vTPM in Confidential VMs","item":"https://gjolly.fr/blog/ek-cvm-binding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The trust model of vTPM in Confidential VMs","name":"The trust model of vTPM in Confidential VMs","description":"In a previous post, I explained that the direction most Confidential Computing deployments are converging toward is to reintroduce the TPM abstraction inside the Confidential VM itself. Rather than relying on a physical TPM, the goal is to expose a TPM interface from within the TEE.\nThis design choice is largely pragmatic. It enables a lift-and-shift model for existing operating systems and workloads that already depend on TPMs for measured boot, disk encryption, and remote attestation. At the same time, it preserves the familiar TPM security guarantees while replacing physical trust assumptions with hardware-enforced isolation.\n","keywords":["Confidential Computing","TPM"],"articleBody":"In a previous post, I explained that the direction most Confidential Computing deployments are converging toward is to reintroduce the TPM abstraction inside the Confidential VM itself. Rather than relying on a physical TPM, the goal is to expose a TPM interface from within the TEE.\nThis design choice is largely pragmatic. It enables a lift-and-shift model for existing operating systems and workloads that already depend on TPMs for measured boot, disk encryption, and remote attestation. At the same time, it preserves the familiar TPM security guarantees while replacing physical trust assumptions with hardware-enforced isolation.\nImage credit: Microsoft\nTo make this work, the vTPM cannot run inside the guest kernel. Instead, it is hosted by a small, highly privileged runtime that sits above the guest OS. Two concrete examples of this approach are coconut-svsm in the AMD SEV-SNP ecosystem and OpenHCL in Microsoft’s confidential computing stack.\nThese components are sometimes called firmware, but that label hides an important detail. They are not just boot-time code like UEFI. They are resident runtimes, measured at VM launch, executing at a higher privilege level than the guest kernel, and entered whenever the VM performs a confidential-computing exit. In practice, they act as paravisors, hosting security-critical services such as memory validation, device mediation, and the vTPM itself.\nImage credit: Microsoft\nA question that puzzled me for a while Once you accept that the TPM abstraction belongs inside the CVM, a subtle problem appears.\nIf the vTPM is part of the trusted computing base, then its build must be reproducible. Otherwise, remote attestation loses its meaning: you cannot verify that the code you audited is the code that is actually running.\nAt the same time, a TPM is defined by the presence of an Endorsement Key (EK). That key must be unique to each TPM instance, must never be disclosed in private form, and serves as the root of identity for TPM credentials and attestation keys.\nAt first glance, these requirements appear incompatible. How can a reproducibly built vTPM binary “contain” a unique EK? And if the EK is generated dynamically, how can a remote verifier trust that this EK belongs to a genuine vTPM rather than to a compromised guest kernel impersonating one?\nA quick reminder: what the EK is actually about The EK is not just another TPM key. It is the identity anchor of the TPM. Everything else, attestation keys, quotes, credentials, derives its trust from the assumption that the EK private key is held only by a genuine TPM.\nOn physical hardware, that trust comes from manufacturing: the EK is injected at the factory and certified by the vendor. In a virtual TPM, there is no factory and no physical chip. The question becomes: what replaces that root of trust?\nWhy the naïve approach fails Assume a realistic threat model where the guest kernel and disk are untrusted.\nIf the kernel is compromised, it can fabricate PCR values, invent TPM quotes, and generate arbitrary key pairs while claiming they are TPM keys. If the verifier has no prior trust anchor for the EK (no certificate chain, no pinned public key) then such claims are indistinguishable from legitimate ones.\nSimply generating an EK at runtime is therefore insufficient. Without a way to bind that key to something the verifier already trusts, any kernel can pretend to be a vTPM.\nReproducibility versus identity: separating concerns The resolution starts by separating two ideas that are often conflated.\nReproducibility applies to code, not to instance-specific secrets. The vTPM binary and the paravisor hosting it must be reproducible so their measurements can be verified. The EK is runtime state, generated after launch, and does not belong in the build output.\nThat separation removes the apparent contradiction, but it leaves one remaining question: how does a remote verifier learn that this runtime-generated EK was created inside a specific, attested vTPM implementation?\nThis is where key binding enters the picture.\nThe key binding mechanism Modern confidential-computing attestation formats, such as SEV-SNP reports and Intel TDX quotes, include a small field commonly called REPORT_DATA. This field is covered by the hardware signature and therefore becomes part of what the verifier ultimately trusts.\nThe crucial point (and the source of my original confusion) is who actually controls this field.\nAlthough the guest kernel may initiate the attestation request, the request is handled by the paravisor. The kernel does not talk directly to the hardware attestation engine. Instead, it exits into the paravisor, and execution continues there. From that point on, the kernel is no longer running.\nThis means that whatever the kernel might attempt to place into REPORT_DATA is not authoritative. The paravisor interprets the request, computes the data it wants to bind, and places its own value into the attestation structure. Any kernel-supplied value is ignored or overwritten.\nWith that in mind, the binding process becomes straightforward.\nAt runtime, the vTPM generates its EK (or, more commonly, an Attestation Key derived from it). The private key never leaves the paravisor-controlled environment. When an attestation is requested, the paravisor computes a binding value (typically a hash over the public key and a verifier-provided nonce) and writes that value into the REPORT_DATA field.\nThe hardware then signs an attestation report that covers the paravisor measurement, security attributes, and this REPORT_DATA field. When the verifier checks the report, it verifies not only that the paravisor is the expected one, but also that the reported binding matches the vTPM key it was given.\nAt that point, the verifier can conclude that this key was generated by a vTPM running inside a specific, attested paravisor instance.\nWhy a compromised kernel cannot fake this Even though the kernel triggers the attestation request, it is not part of the signing path. Once the VM exits, execution moves into the paravisor, which controls both the binding computation and the attestation request to the hardware.\nThe kernel can relay messages, but it cannot inject its own key into the attestation, cannot modify the signed report, and cannot produce TPM quotes signed with the bound private key. Any attempt to fabricate vTPM evidence will fail either at attestation verification time or when TPM signatures are checked.\nConclusion This design resolves the original paradox cleanly.\nThe vTPM and paravisor binaries remain fully reproducible and auditable. The EK is unique and secret, generated at runtime rather than embedded in the build. And trust in that EK comes not from preinstalled certificates, but from cryptographic binding to a hardware-attested execution environment.\nIn short, the EK does not need to be trusted a priori. It only needs to be proven to exist inside the right place.\nReferences Intel TD Partitioning and vTPM on COCONUT-SVSM AMD SEV-SNP Attestation: Establishing Trust in Guests OpenHCL: the new, open source paravisor ","wordCount":"1124","inLanguage":"en","datePublished":"2026-01-21T17:30:00Z","dateModified":"2026-01-21T17:30:00Z","author":{"@type":"Person","name":"Gauthier Jolly"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gjolly.fr/blog/ek-cvm-binding/"},"publisher":{"@type":"Organization","name":"Gauthier Jolly","logo":{"@type":"ImageObject","url":"https://gjolly.fr/img/terminal-sign.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gjolly.fr/ accesskey=h title="Home (Alt + H)"><img src=https://gjolly.fr/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://gjolly.fr/blog/ title=blog><span>blog</span></a></li><li><a href=https://gjolly.fr/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gjolly.fr/>Home</a>&nbsp;»&nbsp;<a href=https://gjolly.fr/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">The trust model of vTPM in Confidential VMs</h1><div class=post-meta><span title='2026-01-21 17:30:00 +0000 UTC'>January 21, 2026</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Gauthier Jolly</div></header><div class=post-content><p><a href=https://gjolly.fr/blog/confidential-computing-vision/>In a previous post</a>, I explained that the direction most Confidential Computing deployments are converging toward is to <strong>reintroduce the TPM abstraction inside the Confidential VM itself</strong>. Rather than relying on a physical TPM, the goal is to expose a TPM interface from within the TEE.</p><p>This design choice is largely pragmatic. It enables a lift-and-shift model for existing operating systems and workloads that already depend on TPMs for measured boot, disk encryption, and remote attestation. At the same time, it preserves the familiar TPM security guarantees while replacing physical trust assumptions with hardware-enforced isolation.</p><p><img alt="vTPM in Confidential VM" loading=lazy src=https://gjolly.fr/images/vtpm-in-confidential-vm-diagram.png>
<em>Image credit: <a href=https://learn.microsoft.com/fr-fr/azure/confidential-computing/virtual-tpms-in-azure-confidential-vm>Microsoft</a></em></p><p>To make this work, the vTPM cannot run inside the guest kernel. Instead, it is hosted by a small, highly privileged runtime that sits <em>above</em> the guest OS. Two concrete examples of this approach are <strong>coconut-svsm</strong> in the AMD SEV-SNP ecosystem and <strong>OpenHCL</strong> in Microsoft’s confidential computing stack.</p><p>These components are sometimes called <em>firmware</em>, but that label hides an important detail. They are not just boot-time code like UEFI. They are <strong>resident runtimes</strong>, measured at VM launch, executing at a higher privilege level than the guest kernel, and entered whenever the VM performs a confidential-computing exit. In practice, they act as <em>paravisors</em>, hosting security-critical services such as memory validation, device mediation, and the vTPM itself.</p><p><img alt=OpenHCL loading=lazy src=https://gjolly.fr/images/openhcl.png>
<em>Image credit: <a href=https://techcommunity.microsoft.com/blog/windowsosplatform/openhcl-the-new-open-source-paravisor/4273172>Microsoft</a></em></p><hr><h2 id=a-question-that-puzzled-me-for-a-while>A question that puzzled me for a while<a hidden class=anchor aria-hidden=true href=#a-question-that-puzzled-me-for-a-while>#</a></h2><p>Once you accept that the TPM abstraction belongs inside the CVM, a subtle problem appears.</p><p>If the vTPM is part of the trusted computing base, then its build must be <strong>reproducible</strong>. Otherwise, remote attestation loses its meaning: you cannot verify that the code you audited is the code that is actually running.</p><p>At the same time, a TPM is defined by the presence of an <strong>Endorsement Key (EK)</strong>. That key must be unique to each TPM instance, must never be disclosed in private form, and serves as the root of identity for TPM credentials and attestation keys.</p><p>At first glance, these requirements appear incompatible. How can a reproducibly built vTPM binary “contain” a unique EK? And if the EK is generated dynamically, how can a remote verifier trust that this EK belongs to a genuine vTPM rather than to a compromised guest kernel impersonating one?</p><hr><h2 id=a-quick-reminder-what-the-ek-is-actually-about>A quick reminder: what the EK is actually about<a hidden class=anchor aria-hidden=true href=#a-quick-reminder-what-the-ek-is-actually-about>#</a></h2><p>The EK is not just another TPM key. It is the <strong>identity anchor</strong> of the TPM. Everything else, attestation keys, quotes, credentials, derives its trust from the assumption that the EK private key is held only by a genuine TPM.</p><p>On physical hardware, that trust comes from manufacturing: the EK is injected at the factory and certified by the vendor. In a virtual TPM, there is no factory and no physical chip. The question becomes: <em>what replaces that root of trust?</em></p><hr><h2 id=why-the-naïve-approach-fails>Why the naïve approach fails<a hidden class=anchor aria-hidden=true href=#why-the-naïve-approach-fails>#</a></h2><p>Assume a realistic threat model where the guest kernel and disk are untrusted.</p><p>If the kernel is compromised, it can fabricate PCR values, invent TPM quotes, and generate arbitrary key pairs while claiming they are TPM keys. If the verifier has no prior trust anchor for the EK (no certificate chain, no pinned public key) then such claims are indistinguishable from legitimate ones.</p><p>Simply generating an EK at runtime is therefore insufficient. Without a way to bind that key to something the verifier already trusts, any kernel can pretend to be a vTPM.</p><hr><h2 id=reproducibility-versus-identity-separating-concerns>Reproducibility versus identity: separating concerns<a hidden class=anchor aria-hidden=true href=#reproducibility-versus-identity-separating-concerns>#</a></h2><p>The resolution starts by separating two ideas that are often conflated.</p><p>Reproducibility applies to <strong>code</strong>, not to <strong>instance-specific secrets</strong>. The vTPM binary and the paravisor hosting it must be reproducible so their measurements can be verified. The EK is runtime state, generated after launch, and does not belong in the build output.</p><p>That separation removes the apparent contradiction, but it leaves one remaining question: how does a remote verifier learn that this runtime-generated EK was created <em>inside</em> a specific, attested vTPM implementation?</p><p>This is where key binding enters the picture.</p><hr><h2 id=the-key-binding-mechanism>The key binding mechanism<a hidden class=anchor aria-hidden=true href=#the-key-binding-mechanism>#</a></h2><p>Modern confidential-computing attestation formats, such as SEV-SNP reports and Intel TDX quotes, include a small field commonly called <code>REPORT_DATA</code>. This field is covered by the hardware signature and therefore becomes part of what the verifier ultimately trusts.</p><p>The crucial point (and the source of my original confusion) is <strong>who actually controls this field</strong>.</p><p>Although the guest kernel may initiate the attestation request, the request is <strong>handled by the paravisor</strong>. The kernel does not talk directly to the hardware attestation engine. Instead, it exits into the paravisor, and execution continues there. From that point on, the kernel is no longer running.</p><p>This means that whatever the kernel might attempt to place into <code>REPORT_DATA</code> is not authoritative. The paravisor interprets the request, computes the data it wants to bind, and places <em>its own</em> value into the attestation structure. Any kernel-supplied value is ignored or overwritten.</p><p>With that in mind, the binding process becomes straightforward.</p><p>At runtime, the vTPM generates its EK (or, more commonly, an Attestation Key derived from it). The private key never leaves the paravisor-controlled environment. When an attestation is requested, the paravisor computes a binding value (typically a hash over the public key and a verifier-provided nonce) and writes that value into the <code>REPORT_DATA</code> field.</p><p>The hardware then signs an attestation report that covers the paravisor measurement, security attributes, and this <code>REPORT_DATA</code> field. When the verifier checks the report, it verifies not only that the paravisor is the expected one, but also that the reported binding matches the vTPM key it was given.</p><p>At that point, the verifier can conclude that this key was generated by a vTPM running inside a specific, attested paravisor instance.</p><hr><h2 id=why-a-compromised-kernel-cannot-fake-this>Why a compromised kernel cannot fake this<a hidden class=anchor aria-hidden=true href=#why-a-compromised-kernel-cannot-fake-this>#</a></h2><p>Even though the kernel triggers the attestation request, it is not part of the signing path. Once the VM exits, execution moves into the paravisor, which controls both the binding computation and the attestation request to the hardware.</p><p>The kernel can relay messages, but it cannot inject its own key into the attestation, cannot modify the signed report, and cannot produce TPM quotes signed with the bound private key. Any attempt to fabricate vTPM evidence will fail either at attestation verification time or when TPM signatures are checked.</p><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This design resolves the original paradox cleanly.</p><p>The vTPM and paravisor binaries remain fully reproducible and auditable. The EK is unique and secret, generated at runtime rather than embedded in the build. And trust in that EK comes not from preinstalled certificates, but from cryptographic binding to a hardware-attested execution environment.</p><p>In short, the EK does not need to be trusted <em>a priori</em>. It only needs to be proven to exist <strong>inside the right place</strong>.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href="https://lpc.events/event/18/contributions/1918/attachments/1632/3406/02-lpc2024_mc_tdp_vtpm.pdf?utm_source=chatgpt.com">Intel TD Partitioning and vTPM on
COCONUT-SVSM</a></li><li><a href=https://www.amd.com/content/dam/amd/en/documents/developer/lss-snp-attestation.pdf>AMD SEV-SNP
Attestation: Establishing
Trust in Guests</a></li><li><a href=https://techcommunity.microsoft.com/blog/windowsosplatform/openhcl-the-new-open-source-paravisor/4273172>OpenHCL: the new, open source paravisor</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://gjolly.fr/tags/confidential-computing/>Confidential Computing</a></li><li><a href=https://gjolly.fr/tags/tpm/>TPM</a></li></ul><nav class=paginav><a class=next href=https://gjolly.fr/blog/confidential-ai-inference/><span class=title>Next »</span><br><span>The race toward Confidential AI inference</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://gjolly.fr/>Gauthier Jolly</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>