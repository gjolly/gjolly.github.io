<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Attestable Immutable Nodes for Kubernetes | Gauthier Jolly</title><meta name=keywords content="Confidential Computing,Linux,Kubernetes"><meta name=description content="How immutable operating systems and Confidential Computing can provide a trustworthy foundation for Kubernetes worker nodes"><meta name=author content="Gauthier Jolly"><link rel=canonical href=https://gjolly.fr/blog/confidential-computing-vision/><link crossorigin=anonymous href=https://gjolly.fr/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://gjolly.fr/img/terminal-sign.svg><link rel=icon type=image/png sizes=16x16 href=https://gjolly.fr/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gjolly.fr/favicon-32x32.png><link rel=apple-touch-icon href=https://gjolly.fr/apple-touch-icon.png><link rel=mask-icon href=https://gjolly.fr/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://gjolly.fr/blog/confidential-computing-vision/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4G50Q2695"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4G50Q2695")}</script><meta property="og:url" content="https://gjolly.fr/blog/confidential-computing-vision/"><meta property="og:site_name" content="Gauthier Jolly"><meta property="og:title" content="Attestable Immutable Nodes for Kubernetes"><meta property="og:description" content="How immutable operating systems and Confidential Computing can provide a trustworthy foundation for Kubernetes worker nodes"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-14T15:30:00+00:00"><meta property="article:modified_time" content="2026-01-14T15:30:00+00:00"><meta property="article:tag" content="Confidential Computing"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Kubernetes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Attestable Immutable Nodes for Kubernetes"><meta name=twitter:description content="How immutable operating systems and Confidential Computing can provide a trustworthy foundation for Kubernetes worker nodes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://gjolly.fr/blog/"},{"@type":"ListItem","position":2,"name":"Attestable Immutable Nodes for Kubernetes","item":"https://gjolly.fr/blog/confidential-computing-vision/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Attestable Immutable Nodes for Kubernetes","name":"Attestable Immutable Nodes for Kubernetes","description":"How immutable operating systems and Confidential Computing can provide a trustworthy foundation for Kubernetes worker nodes","keywords":["Confidential Computing","Linux","Kubernetes"],"articleBody":"Rethinking the Trust Boundary of Kubernetes Nodes Most Kubernetes security mechanisms implicitly assume that worker nodes are trustworthy. In practice, this assumption is weak. The operating systems running underneath Kubernetes are often mutable, difficult to audit, and only loosely tied to what was originally provisioned. Even when containers are well isolated and supply chains are secured, a compromised or drifted node OS undermines the entire stack.\nA more robust approach is to treat the node operating system as a security boundary, not just a runtime dependency. This is where immutable and attestable operating systems become relevant. By making the OS immutable and cryptographically verifiable, Kubernetes can rely on a foundation whose integrity is provable rather than assumed.\nThe Android Analogy: A Proven Security Model A useful comparison can be made with the Android ecosystem. Android devices rely on an immutable, verified operating system image that is measured during boot. Applications are isolated and distributed independently, but they always execute on top of a system image whose integrity can be verified through hardware-backed attestation.\nKubernetes already mirrors the Android model at the application level. Workloads are packaged as OCI containers, deployed declaratively, and isolated using kernel primitives. What is missing is the equivalent of Android’s verified system image for Kubernetes worker nodes.\nIn an immutable Kubernetes node model, the cluster of operating systems plays the same role as Android’s system image, while Kubernetes workloads remain OCI containers. The result is a clean separation: the OS provides a verifiable execution substrate, and applications remain portable and replaceable.\nImmutability as a Baseline, Not the End Goal Immutability ensures that once a node boots, its operating system cannot be modified through conventional means, including package management or ad-hoc configuration changes. Updates happen by replacing the entire image rather than mutating the running system. This significantly reduces configuration drift and limits the impact of post-boot compromise.\nHowever, immutability alone does not establish trust. A node may be immutable and still boot an unknown or malicious image. To build a meaningful security foundation, immutability must be paired with attestation.\nTPM-Backed Attestation A Trusted Platform Module (TPM) is a hardware component that provides cryptographic capabilities for secure boot and attestation. During the boot process, the TPM measures each component loaded—firmware, bootloader, kernel, initramfs, and configuration—by computing and storing cryptographic hashes in its Platform Configuration Registers (PCRs).\nThese measurements form a chain of trust: each boot stage measures the next before transferring control to it. Because the TPM is a dedicated hardware component, these measurements cannot be forged by software running on the system. Once the system is fully booted, the PCR values represent a cryptographic summary of exactly what was loaded.\nRemote attestation leverages these measurements. The TPM can produce a signed quote containing PCR values, which an external verifier can check against expected values. This allows the verifier to confirm not only that a node booted successfully, but precisely what it booted.\nConfidential Computing: When Your Node is a VM But what happens if your node is a VM and there is no physical TPM available?\nThis is where Confidential Computing provides a solution. When Kubernetes worker nodes run as Confidential Virtual Machines, their memory is protected by hardware-enforced isolation (using technologies like AMD SEV-SNP or Intel TDX), and a virtual TPM (vTPM) operates inside the VM’s Trusted Execution Environment.\nImage credit: Microsoft\nThis vTPM is not merely a software abstraction. Its state and keys are shielded from the host and cloud operator, protected by the same hardware isolation that secures the VM’s memory. It can produce cryptographic evidence about the VM’s boot process that is verifiably bound to the hardware Trusted Execution Environment.\nAs a result, measurements collected during boot can be trusted as originating from the node itself rather than from the cloud provider or hypervisor. This extends the TPM-based attestation model to virtualized environments while maintaining the same security properties.\nMaking Attestation Durable with UKIs and dm-verity For attestation to be meaningful, measurements must correspond to the system that continues running after boot. Measuring a kernel and initramfs is insufficient if the root filesystem can later be altered without detection.\nA practical solution combines Unified Kernel Images with dm-verity. A UKI packages the kernel, initramfs, and kernel command line into a single, signed, and measurable artifact. This ensures that early boot components and boot parameters are cryptographically bound together.\nThe root filesystem is protected using dm-verity, with its root hash embedded directly in the kernel command line. Because the command line is part of the UKI, it is included in the boot measurements recorded by the TPM. At runtime, dm-verity enforces the integrity of the root filesystem: any modification results in I/O errors rather than silent corruption.\nThis design has an important consequence. Launch-time attestation remains valid during runtime, because the system cannot diverge from the measured state without being detected. The node is not only attestable at boot, but continuously constrained to the attested configuration.\nAlignment with Current Cloud Provider Efforts This approach is consistent with what major cloud providers are already attempting with attestable virtual machine images and TPM-backed measurement pipelines. The use of hardware-assisted isolation and TPM-based attestation, such as those exposed through Nitro-based platforms, reflects the same core idea: the VM image should be a verifiable security boundary.\nApplying this model explicitly to Kubernetes worker nodes simply acknowledges that the node OS is a critical part of the trusted computing base, not an implementation detail.\nCurrent Limitations Despite the maturity of the underlying technologies, Kubernetes itself does not yet integrate remote attestation into its node lifecycle. There is no native mechanism to verify attestation evidence during node provisioning, nor to make scheduling or admission decisions based on node integrity claims. Existing solutions rely on custom bootstrap logic and external verification services.\nAnother limitation is the reliance on cloud-provided firmware and TEE implementations. While Confidential Computing significantly raises the bar, the initial root of trust is still controlled by the cloud provider. This constrains transparency and limits portability across environments.\nBeyond CPUs: Toward Confidential AI Inference The same architectural principles extend naturally to accelerators. GPUs are increasingly gaining confidential execution capabilities, including protected memory and attestation support. When combined with an immutable, attestable node OS, this opens the door to end-to-end confidential AI inference.\nIn such a model, the operating system, Kubernetes runtime, AI framework, and GPU execution context can all be verified. This enables strong guarantees for sensitive inference workloads, where both models and data must remain protected even from infrastructure operators.\nImage credit: NVIDIA\nConclusion Bringing an Android-like security model to infrastructure is a significant step. The constraints are different, the environments are more heterogeneous, and the trust boundaries are harder to define. Still, the building blocks are starting to align. Confidential Computing, hardware-backed isolation, and TPMs operating inside TEEs make it increasingly practical to reason about node integrity in concrete terms.\nWhile Kubernetes does not yet fully integrate these mechanisms, the direction is clear. As confidential VMs and attestable execution environments become more widely available, treating the node OS as a verifiable foundation rather than an opaque substrate appears less experimental and more like a natural evolution of infrastructure security.\nReferences Microsoft: Virtual TPMs in Azure Confidential VMs NVIDIA: Confidential Computing on H100 GPUs for Secure and Trustworthy AI Linux Kernel: dm-verity UAPI Group: Unified Kernel Image (UKI) AWS Attestable AMIs ","wordCount":"1224","inLanguage":"en","datePublished":"2026-01-14T15:30:00Z","dateModified":"2026-01-14T15:30:00Z","author":{"@type":"Person","name":"Gauthier Jolly"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gjolly.fr/blog/confidential-computing-vision/"},"publisher":{"@type":"Organization","name":"Gauthier Jolly","logo":{"@type":"ImageObject","url":"https://gjolly.fr/img/terminal-sign.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gjolly.fr/ accesskey=h title="Home (Alt + H)"><img src=https://gjolly.fr/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://gjolly.fr/blog/ title=blog><span>blog</span></a></li><li><a href=https://gjolly.fr/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gjolly.fr/>Home</a>&nbsp;»&nbsp;<a href=https://gjolly.fr/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Attestable Immutable Nodes for Kubernetes</h1><div class=post-description>How immutable operating systems and Confidential Computing can provide a trustworthy foundation for Kubernetes worker nodes</div><div class=post-meta><span title='2026-01-14 15:30:00 +0000 UTC'>January 14, 2026</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Gauthier Jolly</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#rethinking-the-trust-boundary-of-kubernetes-nodes>Rethinking the Trust Boundary of Kubernetes Nodes</a></li><li><a href=#the-android-analogy-a-proven-security-model>The Android Analogy: A Proven Security Model</a></li><li><a href=#immutability-as-a-baseline-not-the-end-goal>Immutability as a Baseline, Not the End Goal</a></li><li><a href=#tpm-backed-attestation>TPM-Backed Attestation</a></li><li><a href=#confidential-computing-when-your-node-is-a-vm>Confidential Computing: When Your Node is a VM</a></li><li><a href=#making-attestation-durable-with-ukis-and-dm-verity>Making Attestation Durable with UKIs and dm-verity</a></li><li><a href=#alignment-with-current-cloud-provider-efforts>Alignment with Current Cloud Provider Efforts</a></li><li><a href=#current-limitations>Current Limitations</a></li><li><a href=#beyond-cpus-toward-confidential-ai-inference>Beyond CPUs: Toward Confidential AI Inference</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=rethinking-the-trust-boundary-of-kubernetes-nodes>Rethinking the Trust Boundary of Kubernetes Nodes<a hidden class=anchor aria-hidden=true href=#rethinking-the-trust-boundary-of-kubernetes-nodes>#</a></h2><p>Most Kubernetes security mechanisms implicitly assume that worker nodes are trustworthy. In practice, this assumption is weak. The operating systems running underneath Kubernetes are often mutable, difficult to audit, and only loosely tied to what was originally provisioned. Even when containers are well isolated and supply chains are secured, a compromised or drifted node OS undermines the entire stack.</p><p>A more robust approach is to treat the node operating system as a <strong>security boundary</strong>, not just a runtime dependency. This is where immutable and attestable operating systems become relevant. By making the OS immutable and cryptographically verifiable, Kubernetes can rely on a foundation whose integrity is provable rather than assumed.</p><hr><h2 id=the-android-analogy-a-proven-security-model>The Android Analogy: A Proven Security Model<a hidden class=anchor aria-hidden=true href=#the-android-analogy-a-proven-security-model>#</a></h2><p>A useful comparison can be made with the Android ecosystem. Android devices rely on an immutable, verified operating system image that is measured during boot. Applications are isolated and distributed independently, but they always execute on top of a system image whose integrity can be verified through hardware-backed attestation.</p><p>Kubernetes already mirrors the Android model at the application level. Workloads are packaged as OCI containers, deployed declaratively, and isolated using kernel primitives. What is missing is the equivalent of Android’s verified system image for Kubernetes worker nodes.</p><p>In an immutable Kubernetes node model, the cluster of operating systems plays the same role as Android’s system image, while Kubernetes workloads remain OCI containers. The result is a clean separation: the OS provides a verifiable execution substrate, and applications remain portable and replaceable.</p><hr><h2 id=immutability-as-a-baseline-not-the-end-goal>Immutability as a Baseline, Not the End Goal<a hidden class=anchor aria-hidden=true href=#immutability-as-a-baseline-not-the-end-goal>#</a></h2><p>Immutability ensures that once a node boots, its operating system cannot be modified through conventional means, including package management or ad-hoc configuration changes. Updates happen by replacing the entire image rather than mutating the running system. This significantly reduces configuration drift and limits the impact of post-boot compromise.</p><p>However, immutability alone does not establish trust. A node may be immutable and still boot an unknown or malicious image. To build a meaningful security foundation, immutability must be paired with <strong>attestation</strong>.</p><hr><h2 id=tpm-backed-attestation>TPM-Backed Attestation<a hidden class=anchor aria-hidden=true href=#tpm-backed-attestation>#</a></h2><p>A Trusted Platform Module (TPM) is a hardware component that provides cryptographic capabilities for secure boot and attestation. During the boot process, the TPM measures each component loaded—firmware, bootloader, kernel, initramfs, and configuration—by computing and storing cryptographic hashes in its Platform Configuration Registers (PCRs).</p><p>These measurements form a chain of trust: each boot stage measures the next before transferring control to it. Because the TPM is a dedicated hardware component, these measurements cannot be forged by software running on the system. Once the system is fully booted, the PCR values represent a cryptographic summary of exactly what was loaded.</p><p>Remote attestation leverages these measurements. The TPM can produce a signed quote containing PCR values, which an external verifier can check against expected values. This allows the verifier to confirm not only that a node booted successfully, but precisely <em>what</em> it booted.</p><hr><h2 id=confidential-computing-when-your-node-is-a-vm>Confidential Computing: When Your Node is a VM<a hidden class=anchor aria-hidden=true href=#confidential-computing-when-your-node-is-a-vm>#</a></h2><p>But what happens if your node is a VM and there is no physical TPM available?</p><p>This is where Confidential Computing provides a solution. When Kubernetes worker nodes run as Confidential Virtual Machines, their memory is protected by hardware-enforced isolation (using technologies like AMD SEV-SNP or Intel TDX), and a virtual TPM (vTPM) operates inside the VM&rsquo;s Trusted Execution Environment.</p><p><img alt="vTPM in Confidential VM" loading=lazy src=https://gjolly.fr/images/vtpm-in-confidential-vm-diagram.png>
<em>Image credit: <a href=https://learn.microsoft.com/fr-fr/azure/confidential-computing/virtual-tpms-in-azure-confidential-vm>Microsoft</a></em></p><p>This vTPM is not merely a software abstraction. Its state and keys are shielded from the host and cloud operator, protected by the same hardware isolation that secures the VM&rsquo;s memory. It can produce cryptographic evidence about the VM&rsquo;s boot process that is verifiably bound to the hardware Trusted Execution Environment.</p><p>As a result, measurements collected during boot can be trusted as originating from the node itself rather than from the cloud provider or hypervisor. This extends the TPM-based attestation model to virtualized environments while maintaining the same security properties.</p><hr><h2 id=making-attestation-durable-with-ukis-and-dm-verity>Making Attestation Durable with UKIs and dm-verity<a hidden class=anchor aria-hidden=true href=#making-attestation-durable-with-ukis-and-dm-verity>#</a></h2><p>For attestation to be meaningful, measurements must correspond to the system that continues running after boot. Measuring a kernel and initramfs is insufficient if the root filesystem can later be altered without detection.</p><p>A practical solution combines Unified Kernel Images with dm-verity. A UKI packages the kernel, initramfs, and kernel command line into a single, signed, and measurable artifact. This ensures that early boot components and boot parameters are cryptographically bound together.</p><p>The root filesystem is protected using dm-verity, with its root hash embedded directly in the kernel command line. Because the command line is part of the UKI, it is included in the boot measurements recorded by the TPM. At runtime, dm-verity enforces the integrity of the root filesystem: any modification results in I/O errors rather than silent corruption.</p><p><img alt="Immutable Attestable Node Architecture" loading=lazy src=https://gjolly.fr/images/immutable-attestable-node-architecture.png></p><p>This design has an important consequence. <strong>Launch-time attestation remains valid during runtime</strong>, because the system cannot diverge from the measured state without being detected. The node is not only attestable at boot, but continuously constrained to the attested configuration.</p><hr><h2 id=alignment-with-current-cloud-provider-efforts>Alignment with Current Cloud Provider Efforts<a hidden class=anchor aria-hidden=true href=#alignment-with-current-cloud-provider-efforts>#</a></h2><p>This approach is consistent with what major cloud providers are already attempting with attestable virtual machine images and TPM-backed measurement pipelines. The use of hardware-assisted isolation and TPM-based attestation, such as those exposed through Nitro-based platforms, reflects the same core idea: the VM image should be a verifiable security boundary.</p><p>Applying this model explicitly to Kubernetes worker nodes simply acknowledges that the node OS is a critical part of the trusted computing base, not an implementation detail.</p><hr><h2 id=current-limitations>Current Limitations<a hidden class=anchor aria-hidden=true href=#current-limitations>#</a></h2><p>Despite the maturity of the underlying technologies, Kubernetes itself does not yet integrate remote attestation into its node lifecycle. There is no native mechanism to verify attestation evidence during node provisioning, nor to make scheduling or admission decisions based on node integrity claims. Existing solutions rely on custom bootstrap logic and external verification services.</p><p>Another limitation is the reliance on cloud-provided firmware and TEE implementations. While Confidential Computing significantly raises the bar, the initial root of trust is still controlled by the cloud provider. This constrains transparency and limits portability across environments.</p><hr><h2 id=beyond-cpus-toward-confidential-ai-inference>Beyond CPUs: Toward Confidential AI Inference<a hidden class=anchor aria-hidden=true href=#beyond-cpus-toward-confidential-ai-inference>#</a></h2><p>The same architectural principles extend naturally to accelerators. GPUs are increasingly gaining confidential execution capabilities, including protected memory and attestation support. When combined with an immutable, attestable node OS, this opens the door to end-to-end confidential AI inference.</p><p>In such a model, the operating system, Kubernetes runtime, AI framework, and GPU execution context can all be verified. This enables strong guarantees for sensitive inference workloads, where both models and data must remain protected even from infrastructure operators.</p><p><img alt="Confidential AI Inference Topology" loading=lazy src=https://gjolly.fr/images/example-topology-4-gpu.png>
<em>Image credit: <a href=https://developer.nvidia.com/blog/confidential-computing-on-h100-gpus-for-secure-and-trustworthy-ai/>NVIDIA</a></em></p><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Bringing an Android-like security model to infrastructure is a significant step. The constraints are different, the environments are more heterogeneous, and the trust boundaries are harder to define. Still, the building blocks are starting to align. Confidential Computing, hardware-backed isolation, and TPMs operating inside TEEs make it increasingly practical to reason about node integrity in concrete terms.</p><p>While Kubernetes does not yet fully integrate these mechanisms, the direction is clear. As confidential VMs and attestable execution environments become more widely available, treating the node OS as a verifiable foundation rather than an opaque substrate appears less experimental and more like a natural evolution of infrastructure security.</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://learn.microsoft.com/fr-fr/azure/confidential-computing/virtual-tpms-in-azure-confidential-vm>Microsoft: Virtual TPMs in Azure Confidential VMs</a></li><li><a href=https://developer.nvidia.com/blog/confidential-computing-on-h100-gpus-for-secure-and-trustworthy-ai/>NVIDIA: Confidential Computing on H100 GPUs for Secure and Trustworthy AI</a></li><li><a href=https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html>Linux Kernel: dm-verity</a></li><li><a href=https://uapi-group.org/specifications/specs/unified_kernel_image/>UAPI Group: Unified Kernel Image (UKI)</a></li><li><a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/attestable-ami.html>AWS Attestable AMIs</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://gjolly.fr/tags/confidential-computing/>Confidential Computing</a></li><li><a href=https://gjolly.fr/tags/linux/>Linux</a></li><li><a href=https://gjolly.fr/tags/kubernetes/>Kubernetes</a></li></ul><nav class=paginav><a class=prev href=https://gjolly.fr/blog/confidential-ai-inference/><span class=title>« Prev</span><br><span>The race toward Confidential AI inference</span>
</a><a class=next href=https://gjolly.fr/blog/cf-tunnels/><span class=title>Next »</span><br><span>Exposing a local web server using Cloudflare Tunnels</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://gjolly.fr/>Gauthier Jolly</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>